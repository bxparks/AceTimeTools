# Copyright 2018 Brian T. Park
#
# MIT License
"""
Generate the 'zone_infos.py' and 'zone_policies.py' files for Python.
"""

import logging
import os
from typing import List
from typing import Tuple

from acetimetools.data_types.at_types import ZoneEraRaw
from acetimetools.data_types.at_types import ZoneRuleRaw
from acetimetools.data_types.at_types import ZonesMap
from acetimetools.data_types.at_types import LinksMap
from acetimetools.data_types.at_types import PoliciesMap
from acetimetools.data_types.at_types import CommentsMap
from acetimetools.data_types.at_types import MergedCommentsMap
from acetimetools.data_types.at_types import ZoneInfoDatabase
from acetimetools.transformer.transformer import normalize_name
from acetimetools.transformer.transformer import normalize_raw


class PythonGenerator:
    """Generate Python files for zone_infos.py and zone_policies.py which are
    used by the ZoneProcessor class. Unlike the Arduino version, the Python
    implementation does not support the 'Link' zone names.
    """

    ZONE_INFOS_FILE_NAME = 'zone_infos.py'
    ZONE_POLICIES_FILE_NAME = 'zone_policies.py'
    ZONE_REGISTRY_FILE_NAME = 'zone_registry.py'

    def __init__(
        self,
        invocation: str,
        zidb: ZoneInfoDatabase,
    ):
        wrapped_invocation = '\n#     --'.join(invocation.split(' --'))
        wrapped_tzfiles = '\n#   '.join(zidb['tz_files'])
        self.invocation = wrapped_invocation
        self.tz_files = wrapped_tzfiles
        self.tz_version = zidb['tz_version']
        self.start_year = zidb['start_year']
        self.until_year = zidb['until_year']
        self.num_zones = zidb['num_zones']
        self.num_links = zidb['num_links']
        self.num_policies = zidb['num_policies']
        self.num_eras = zidb['num_eras']
        self.num_rules = zidb['num_rules']
        self.zones_map = zidb['zones_map']
        self.links_map = zidb['links_map']
        self.policies_map = zidb['policies_map']
        self.removed_zones = zidb['removed_zones']
        self.removed_links = zidb['removed_links']
        self.removed_policies = zidb['removed_policies']
        self.notable_zones = zidb['notable_zones']
        self.merged_notable_zones = zidb['merged_notable_zones']
        self.notable_links = zidb['notable_links']
        self.notable_policies = zidb['notable_policies']
        self.original_min_year = zidb['original_min_year']
        self.original_max_year = zidb['original_max_year']
        self.generated_min_year = zidb['generated_min_year']
        self.generated_max_year = zidb['generated_max_year']

        self.zones_and_links = (
            list(self.zones_map.keys())
            + list(self.links_map.keys())
        )

    def generate_files(self, output_dir: str) -> None:
        self._write_file(output_dir, self.ZONE_POLICIES_FILE_NAME,
                         self._generate_policies())

        self._write_file(output_dir, self.ZONE_INFOS_FILE_NAME,
                         self._generate_infos())

        self._write_file(output_dir, self.ZONE_REGISTRY_FILE_NAME,
                         self._generate_registry())

    def _write_file(self, output_dir: str, filename: str, content: str) -> None:
        full_filename = os.path.join(output_dir, filename)
        with open(full_filename, 'w', encoding='utf-8') as output_file:
            print(content, end='', file=output_file)
        logging.info("Created %s", full_filename)

    # ------------------------------------------------------------------------
    # File Header
    # ------------------------------------------------------------------------
    def _generate_header(self) -> str:
        num_zones_and_links = self.num_zones + self.num_links
        num_removed_zones = len(self.removed_zones)
        num_removed_links = len(self.removed_links)
        num_removed_zones_and_links = num_removed_zones + num_removed_links

        return f"""\
# This file was generated by the following script:
#
#   $ {self.invocation}
#
# using the TZ Database files
#
#   {self.tz_files}
#
# from https://github.com/eggert/tz/releases/tag/{self.tz_version}
#
# Supported Zones: {num_zones_and_links} \
({self.num_zones} zones, {self.num_links} links)
# Unsupported Zones: {num_removed_zones_and_links} \
({num_removed_zones} zones, {num_removed_links} links)
#
# Original Years:  [{self.original_min_year},{self.original_max_year}]
# Generated Years: [{self.generated_min_year},{self.generated_max_year}]
#
# Records:
#   Infos: {num_zones_and_links}
#   Eras: {self.num_eras}
#   Policies: {self.num_policies}
#   Rules: {self.num_rules}
#
# DO NOT EDIT

"""

    # ------------------------------------------------------------------------
    # Zone Policies
    # ------------------------------------------------------------------------

    def _generate_policies(self) -> str:
        num_rules, policy_items = self._generate_policy_items(self.policies_map)
        removed_policy_items = _render_comments_map(self.removed_policies)
        notable_policy_items = _render_comments_map(self.notable_policies)

        return self._generate_header() + f"""\
from typing import List
from ..typing import (
    ZoneRule,
    ZonePolicy,
)

# ---------------------------------------------------------------------------
# Supported zone policies: {len(self.policies_map)}
# numRules: {num_rules}
# ---------------------------------------------------------------------------

{policy_items}

# ---------------------------------------------------------------------------
# Unsupported zone policies: {len(self.removed_policies)}
# ---------------------------------------------------------------------------

{removed_policy_items}

# ---------------------------------------------------------------------------
# Notable zone policies: {len(self.notable_policies)}
# ---------------------------------------------------------------------------

{notable_policy_items}
"""

    def _generate_policy_items(
        self,
        policies_map: PoliciesMap,
    ) -> Tuple[int, str]:
        num_rules = 0
        policy_items = ''
        for name, rules in sorted(policies_map.items()):
            policy_items += self._generate_policy_item(name, rules)
            num_rules += len(rules)
        return (num_rules, policy_items)

    def _generate_policy_item(
        self,
        policy_name: str,
        rules: List[ZoneRuleRaw],
    ) -> str:
        rule_items = ''
        for rule in rules:
            raw_line = normalize_raw(rule['raw_line'])
            from_year = rule['from_year']
            to_year = rule['to_year']
            in_month = rule['in_month']
            on_day_of_week = rule['on_day_of_week']
            on_day_of_month = rule['on_day_of_month']
            at_seconds = rule['at_seconds_truncated']
            at_time_suffix = rule['at_time_suffix']
            delta_seconds = rule['delta_seconds_truncated']
            letter = rule['letter']

            rule_items += f"""\
    # {raw_line}
    {{
        'from_year': {from_year},
        'to_year': {to_year},
        'in_month': {in_month},
        'on_day_of_week': {on_day_of_week},
        'on_day_of_month': {on_day_of_month},
        'at_seconds': {at_seconds},
        'at_time_suffix': '{at_time_suffix}',
        'delta_seconds': {delta_seconds},
        'letter': '{letter}',
    }},
"""

        policy_normalized_name = normalize_name(policy_name)
        num_rules = len(rules)
        rule_items = rule_items
        return f"""\
# ---------------------------------------------------------------------------
# Policy name: {policy_name}
# Rule count: {num_rules}
# ---------------------------------------------------------------------------
ZONE_RULES_{policy_normalized_name}: List[ZoneRule] = [
{rule_items}
]

ZONE_POLICY_{policy_normalized_name}: ZonePolicy = {{
    'name': '{policy_name}',
    'rules': ZONE_RULES_{policy_normalized_name}
}}

"""

    # ------------------------------------------------------------------------
    # Zone Infos
    # ------------------------------------------------------------------------

    def _generate_infos(self) -> str:
        (num_eras, info_items) = self._generate_info_items(self.zones_map)
        link_items = self._generate_link_items(self.links_map)
        removed_info_items = _render_comments_map(self.removed_zones)
        # notable_info_items = _render_comments_map(self.notable_zones)
        notable_info_items = _render_merged_comments_map(
            self.merged_notable_zones)
        removed_link_items = _render_comments_map(self.removed_links)
        notable_link_items = _render_comments_map(self.notable_links)

        return self._generate_header() + f"""\
from typing import List
from ..typing import (
    ZoneEra,
    ZoneInfo,
)

from .zone_policies import *

# ---------------------------------------------------------------------------
# Zone Context
# ---------------------------------------------------------------------------

TZDB_VERSION = '{self.tz_version}'
START_YEAR = {self.start_year}
UNTIL_YEAR = {self.until_year}

# ---------------------------------------------------------------------------
# Supported zones: {len(self.zones_map)}
# numEras: {num_eras}
# ---------------------------------------------------------------------------

{info_items}

# ---------------------------------------------------------------------------
# Supported links: {len(self.links_map)}
# ---------------------------------------------------------------------------

{link_items}

# ---------------------------------------------------------------------------
# Unsuported zones: {len(self.removed_zones)}
# ---------------------------------------------------------------------------

{removed_info_items}

# ---------------------------------------------------------------------------
# Notable zones: {len(self.notable_zones)}
# ---------------------------------------------------------------------------

{notable_info_items}

# ---------------------------------------------------------------------------
# Unsuported links: {len(self.removed_links)}
# ---------------------------------------------------------------------------

{removed_link_items}

# ---------------------------------------------------------------------------
# Notable links: {len(self.notable_links)}
# ---------------------------------------------------------------------------

{notable_link_items}
"""

    def _generate_info_items(self, zones_map: ZonesMap) -> Tuple[int, str]:
        info_items = ''
        num_eras = 0
        for name, eras in sorted(self.zones_map.items()):
            info_items += self._generate_info_item(name, eras)
            num_eras += len(eras)
        return (num_eras, info_items)

    def _generate_link_items(self, links_map: LinksMap) -> str:
        link_items = ''
        for link_name, zone_name in sorted(links_map.items()):
            link_normalized_name = normalize_name(link_name)
            zone_normalized_name = normalize_name(zone_name)
            link_items += f"""\
# Link name: {link_name} -> {zone_name}
ZONE_INFO_{link_normalized_name}: ZoneInfo = {{
    'name': '{link_name}',
    'link_to': ZONE_INFO_{zone_normalized_name}
}}

"""
        return link_items

    def _generate_info_item(
        self, zone_name: str, eras: List[ZoneEraRaw],
    ) -> str:
        era_items = ''
        for era in eras:
            era_items += self._generate_era_item(era)

        zone_normalized_name = normalize_name(zone_name)
        num_eras = len(eras)
        era_items = era_items

        return f"""\
# ---------------------------------------------------------------------------
# Zone name: {zone_name}
# Era count: {num_eras}
# ---------------------------------------------------------------------------

ZONE_ERAS_{zone_normalized_name}: List[ZoneEra] = [
{era_items}
]

ZONE_INFO_{zone_normalized_name}: ZoneInfo = {{
    'name': '{zone_name}',
    'eras': ZONE_ERAS_{zone_normalized_name}
}}

"""

    def _generate_era_item(self, era: ZoneEraRaw) -> str:
        policy_name = era['policy_name']
        if policy_name is None:
            zone_policy = 'None'
        else:
            policy_normalized_name = normalize_name(policy_name)
            zone_policy = f'ZONE_POLICY_{policy_normalized_name}'

        raw_line = normalize_raw(era['raw_line'])
        offset_seconds = era['offset_seconds_truncated']
        era_delta_seconds = era['era_delta_seconds_truncated']
        format = era['format']  # preserve the %s
        until_year = era['until_year']
        until_month = era['until_month']
        until_day = era['until_day']
        until_seconds = era['until_seconds_truncated']
        until_time_suffix = era['until_time_suffix']

        return f"""\
    # {raw_line}
    {{
        'offset_seconds': {offset_seconds},
        'zone_policy': {zone_policy},
        'era_delta_seconds': {era_delta_seconds},
        'format': '{format}',
        'until_year': {until_year},
        'until_month': {until_month},
        'until_day': {until_day},
        'until_seconds': {until_seconds},
        'until_time_suffix': '{until_time_suffix}',
    }},
"""

    # ------------------------------------------------------------------------
    # Zone Registry
    # ------------------------------------------------------------------------

    def _generate_registry(self) -> str:
        zone_items = self._generate_zone_registry_items(self.zones_map)
        zone_and_link_items = self._generate_zone_and_link_registry_items(
            self.zones_map, self.links_map,)

        numZonesAndLinks = len(self.zones_map) + len(self.links_map)
        return self._generate_header() + f"""\
from ..typing import ZoneInfoMap
from .zone_infos import *

# Supported Zones: {len(self.zones_map)}
ZONE_REGISTRY: ZoneInfoMap = {{
{zone_items}
}}

# Supported Zones and Links: {numZonesAndLinks}
ZONE_AND_LINK_REGISTRY: ZoneInfoMap = {{
{zone_and_link_items}
}}
"""

    def _generate_zone_registry_items(self, zones_map: ZonesMap) -> str:
        """Generate a map of (zone_name -> zoneInfo), sorted by name.
        """
        zone_items = ''
        for zone_name, zones in sorted(zones_map.items()):
            zone_items += f"""\
    '{zone_name}': ZONE_INFO_{normalize_name(zone_name)},
"""
        return zone_items

    def _generate_zone_and_link_registry_items(
        self,
        zones_map: ZonesMap,
        links_map: LinksMap,
    ) -> str:
        """Generate a map of (zone_name -> zoneInfo), for all zones and links,
        sorted by name.
        """
        zone_and_link_items = ''
        for zone_and_link_name in sorted(self.zones_and_links):
            zone_and_link_items += f"""\
    '{zone_and_link_name}': ZONE_INFO_{normalize_name(zone_and_link_name)},
"""
        return zone_and_link_items


def _render_comments_map(comments: CommentsMap, indent: str = '') -> str:
    """Convert the CommentsMap into a Python comment. Print the name and list
    of reasons one a single line, or multiple lines, like this:

    # Name1 {reason}
    #
    # Name2 {
    #   reason1,
    #   reason2,
    # }
    """
    comment = ''
    for name, reasons in sorted(comments.items()):
        if len(reasons) <= 1:
            comment += f"# {indent}{name} {{{next(iter(reasons))}}}\n"
        else:
            comment += f"# {indent}{name} {{\n"
            for reason in reasons:
                comment += f'# {indent}  {reason},\n'
            comment += f"# {indent}}}\n"
    return comment


def _render_merged_comments_map(merged_comments: MergedCommentsMap) -> str:
    """Converts MergedCommentsMap for zones into a C++ comment. Includes the
    comments for zones, as well as any comments in the referenced policies.

    # Name1 {reason}
    #
    # Name2 {
    #   reason1,
    #   reason2,
    # }
    #
    # Name3 {
    #   reason1,
    #   reason2,
    #   Policy1 {reason11}
    #   Policy2 {
    #     reason21,
    #     reason22,
    #   }
    # }
    """
    comment = ''
    for name, reasons in sorted(merged_comments.items()):
        if len(reasons) == 0:
            continue

        # If only a single comment, and the comment is a simple string,
        # render it in a single line.
        reason = next(iter(reasons))
        if len(reasons) == 1 and isinstance(reason, str):
            comment += f"# {name} {{{reason}}}\n"
            continue

        # Otherwise, render the comments using multiple lines deliminted by ( )
        comment += f"# {name} {{\n"
        for reason in reasons:
            if isinstance(reason, str):
                comment += f'#   {reason},\n'
            else:
                comment += _render_comments_map(reason, '  ')
        comment += "# }\n"
    return comment
