# Copyright 2023 Brian T. Park
#
# MIT License
"""
Generate the 'zone_infos.py' and 'zone_policies.py' files for Go lang.
"""

import logging
import os
from typing import Iterable
from typing import List
from typing import Tuple

from acetimetools.data_types.at_types import ZoneEraRaw
from acetimetools.data_types.at_types import ZoneRuleRaw
from acetimetools.data_types.at_types import ZonesMap
from acetimetools.data_types.at_types import LinksMap
from acetimetools.data_types.at_types import PoliciesMap
from acetimetools.data_types.at_types import CommentsMap
from acetimetools.data_types.at_types import MergedCommentsMap
from acetimetools.data_types.at_types import ZoneInfoDatabase
from acetimetools.data_types.at_types import IndexSizeMap
from acetimetools.transformer.transformer import normalize_name
from acetimetools.transformer.transformer import normalize_raw


class GoGenerator:
    """Generate Go lang files (zone_infos.go, zone_policies.go) which are
    used by the ZoneProcessor class.
    """

    ZONE_POLICIES_FILE = """\
// This file was generated by the following script:
//
//   $ {invocation}
//
// using the TZ Database files
//
//   {tz_files}
//
// from https://github.com/eggert/tz/releases/tag/{tz_version}
//
// DO NOT EDIT

package {dbNamespace}

import (
\t"github.com/bxparks/AceTimeGo/zoneinfo"
)

// ---------------------------------------------------------------------------
// String constants.
// ---------------------------------------------------------------------------

const (
\t// All ZoneRule.Letter entries concatenated together.
\tLetterData = "{letterData}"
)

var (
\t// Byte offset into LetterData for each index. The actual Letter string
\t// at index `i` given by the `ZoneRule.Letter` field is
\t// `LetterData[LetterOffsets[i]:LetterOffsets[i+1]]`.
\tLetterOffsets = []uint8{{
{letterOffsets}
\t}}
)

// ---------------------------------------------------------------------------
// ZoneRules is a concatenated array of zoneinfo.ZoneInfo objects from all
// ZonePolicies.
//
// Supported zone policies: {numPolicies}
// numRules: {numRules}
// ---------------------------------------------------------------------------

{zoneRules}

// ---------------------------------------------------------------------------
// ZonePolicies are indexes into the ZoneRules.
// Supported zone policies: {numPolicies}
// ---------------------------------------------------------------------------

{zonePolicies}

// ---------------------------------------------------------------------------
// Unsupported zone policies: {numRemovedPolicies}
// ---------------------------------------------------------------------------

{removedPolicyItems}

// ---------------------------------------------------------------------------
// Notable zone policies: {numNotablePolicies}
// ---------------------------------------------------------------------------

{notablePolicyItems}

"""

    ZONE_INFOS_FILE = """\
// This file was generated by the following script:
//
//   $ {invocation}
//
// using the TZ Database files
//
//   {tz_files}
//
// from https://github.com/eggert/tz/releases/tag/{tz_version}
//
// DO NOT EDIT

package {dbNamespace}

import (
\t"github.com/bxparks/AceTimeGo/zoneinfo"
)

// ---------------------------------------------------------------------------
// String constants.
// ---------------------------------------------------------------------------

const (
\t// All ZoneEra.Format entries concatenated together.
\tFormatData = "{formatData}"

\t// All ZoneInfo.Name entries concatenated togther.
\tNameData = "{nameData}"
)

var (
\t// Byte offset into FormatData for each index. The actual Format string
\t// at index `i` given by the `ZoneEra.Format` field is
\t// `FormatData[FormatOffsets[i]:FormatOffsets[i+1]]`.
\tFormatOffsets = []uint16{{
{formatOffsets}
\t}}

\t// Byte offset into NameData for each index. The actual Letter string
\t// at index `i` given by the `ZoneRule.Name` field is
\t// `NameData[NameOffsets[i]:NameOffsets[i+1]]`.
\tNameOffsets = []uint16{{
{nameOffsets}
\t}}
)

// ---------------------------------------------------------------------------
// Supported zones: {numInfos}
// numEras: {numEras}
// ---------------------------------------------------------------------------

{infoItems}

// ---------------------------------------------------------------------------
// Supported links: {numLinks}
// ---------------------------------------------------------------------------

{linkItems}

// ---------------------------------------------------------------------------
// Unsuported zones: {numRemovedInfos}
// ---------------------------------------------------------------------------

{removedInfoItems}

// ---------------------------------------------------------------------------
// Notable zones: {numNotableInfos}
// ---------------------------------------------------------------------------

{notableInfoItems}

// ---------------------------------------------------------------------------
// Unsuported links: {numRemovedLinks}
// ---------------------------------------------------------------------------

{removedLinkItems}

// ---------------------------------------------------------------------------
// Notable links: {numNotableLinks}
// ---------------------------------------------------------------------------

{notableLinkItems}
"""

    ZONE_ERA_ITEM = """\
\t// {raw_line}
\t{{
\t\tZonePolicy: {zone_policy},
\t\tFormatIndex: {format_index}, // {format_comment}
\t\tOffsetCode: {offset_code},
\t\tDeltaCode: {delta_code}, // {delta_code_comment}
\t\tUntilYear: {until_year},
\t\tUntilMonth: {until_month},
\t\tUntilDay: {until_day},
\t\tUntilTimeCode: {until_time_code},
\t\tUntilTimeModifier: {until_time_modifier}, // {until_time_modifier_comment}
\t}},
"""

    ZONE_REGISTRY_FILE = """\
// This file was generated by the following script:
//
//   $ {invocation}
//
// using the TZ Database files
//
//   {tz_files}
//
// from https://github.com/eggert/tz/releases/tag/{tz_version}
//
// DO NOT EDIT

package {dbNamespace}

import (
\t"github.com/bxparks/AceTimeGo/zoneinfo"
)

// ---------------------------------------------------------------------------
// Zone Context
// ---------------------------------------------------------------------------

const TzDatabaseVersion string = "{tz_version}"

var Context = zoneinfo.ZoneContext{{
\tLetterData: LetterData,
\tLetterOffsets: LetterOffsets,
\tFormatData: FormatData,
\tFormatOffsets: FormatOffsets,
\tNameData: NameData,
\tNameOffsets: NameOffsets,
\tZoneRegistry: ZoneAndLinkRegistry,
\tTzDatabaseVersion: TzDatabaseVersion,
}}

// ---------------------------------------------------------------------------
// Zone Registry
// Total: {numZonesAndLinks} ({numZones} zones, {numLinks} links)
// ---------------------------------------------------------------------------

var ZoneAndLinkRegistry = []*zoneinfo.ZoneInfo{{
{zoneAndLinkItems}
}}

// ---------------------------------------------------------------------------
// Zone IDs
// Total: {numZonesAndLinks} ({numZones} zones, {numLinks} links)
// ---------------------------------------------------------------------------

const (
{zoneAndLinkIds}
)
"""

    ZONE_INFOS_FILE_NAME = 'zone_infos.go'
    ZONE_POLICIES_FILE_NAME = 'zone_policies.go'
    ZONE_REGISTRY_FILE_NAME = 'zone_registry.go'

    def __init__(
        self,
        invocation: str,
        db_namespace: str,
        zidb: ZoneInfoDatabase,
    ):
        wrapped_invocation = '\n//     --'.join(invocation.split(' --'))
        wrapped_tzfiles = '\n//   '.join(zidb['tz_files'])
        self.invocation = wrapped_invocation
        self.tz_files = wrapped_tzfiles
        self.db_namespace = db_namespace
        self.tz_version = zidb['tz_version']
        self.start_year = zidb['start_year']
        self.until_year = zidb['until_year']
        self.zones_map = zidb['zones_map']
        self.links_map = zidb['links_map']
        self.policies_map = zidb['policies_map']
        self.removed_zones = zidb['removed_zones']
        self.removed_links = zidb['removed_links']
        self.removed_policies = zidb['removed_policies']
        self.notable_zones = zidb['notable_zones']
        self.merged_notable_zones = zidb['merged_notable_zones']
        self.notable_links = zidb['notable_links']
        self.notable_policies = zidb['notable_policies']
        self.zone_ids = zidb['zone_ids']
        self.link_ids = zidb['link_ids']
        self.letters_map = zidb['go_letters_map']
        self.formats_map = zidb['go_formats_map']
        self.names_map = zidb['go_names_map']

        self.zones_and_links = (
            list(self.zones_map.keys())
            + list(self.links_map.keys())
        )
        self.zone_and_link_ids = self.zone_ids.copy()
        self.zone_and_link_ids.update(self.link_ids)

    def generate_files(self, output_dir: str) -> None:
        self._write_file(output_dir, self.ZONE_POLICIES_FILE_NAME,
                         self._generate_policies())

        self._write_file(output_dir, self.ZONE_INFOS_FILE_NAME,
                         self._generate_infos())

        self._write_file(output_dir, self.ZONE_REGISTRY_FILE_NAME,
                         self._generate_registry())

    def _write_file(self, output_dir: str, filename: str, content: str) -> None:
        full_filename = os.path.join(output_dir, filename)
        with open(full_filename, 'w', encoding='utf-8') as output_file:
            print(content, end='', file=output_file)
        logging.info("Created %s", full_filename)

    # ------------------------------------------------------------------------
    # Zone Policies
    # ------------------------------------------------------------------------

    def _generate_policies(self) -> str:
        zone_rules_string = self._generate_rules_string(self.policies_map)
        policy_index_map, num_rules = self._generate_policy_index_map(
            self.policies_map
        )
        zone_policies_string = self._generate_policies_string(policy_index_map)
        removed_policy_items = _render_comments_map(self.removed_policies)
        notable_policy_items = _render_comments_map(self.notable_policies)

        letter_data = '" +\n\t\t"'.join(self.letters_map.keys())
        letter_offsets = _render_offsets(
            [x[1] for x in self.letters_map.values()]
        )

        return self.ZONE_POLICIES_FILE.format(
            invocation=self.invocation,
            tz_version=self.tz_version,
            tz_files=self.tz_files,
            dbNamespace=self.db_namespace,
            numPolicies=len(self.policies_map),
            numRules=num_rules,
            zoneRules=zone_rules_string,
            zonePolicies=zone_policies_string,
            numRemovedPolicies=len(self.removed_policies),
            removedPolicyItems=removed_policy_items,
            numNotablePolicies=len(self.notable_policies),
            notablePolicyItems=notable_policy_items,
            letterData=letter_data,
            letterOffsets=letter_offsets,
        )

    def _generate_policy_index_map(
        self, policies_map: PoliciesMap
    ) -> Tuple[IndexSizeMap, int]:

        policy_index = 0
        rules_index = 0
        index_map: IndexSizeMap = {}
        index_map[""] = (0, 0, 0)  # add sentinel for "Null Policy"
        for policy_name, rules in sorted(policies_map.items()):
            index_map[policy_name] = (policy_index, rules_index, len(rules))
            rules_index += len(rules)
            policy_index += 1
        return index_map, rules_index

    def _generate_rules_string(self, policies_map: PoliciesMap) -> str:
        zone_rules_string = """\
var ZoneRules = []zoneinfo.ZoneRule{{
"""
        for policy_name, rules in sorted(policies_map.items()):
            zone_rules_string += self._generate_rule_items_string(
                policy_name, rules)
            zone_rules_string += '\n'
        zone_rules_string += """\
}}
"""
        return zone_rules_string

    def _generate_rule_items_string(
        self, policy_name: str, rules: List[ZoneRuleRaw]
    ) -> str:
        rule_items_string = f"""\
\t// ---------------------------------------------------------------------------
\t// Policy name: {policy_name}
\t// Rule count: {len(rules)}
\t// ---------------------------------------------------------------------------

"""
        for rule in rules:
            at_time_modifier_comment = _get_time_modifier_comment(
                time_seconds=rule['at_seconds_truncated'],
                suffix=rule['at_time_suffix'],
            )
            delta_code_comment = _get_rule_delta_code_comment(
                delta_seconds=rule['delta_seconds_truncated'],
                scope='extended',  # AceTimeGo supports only extended
            )

            # Find the index for the 'letter' field.
            letter = rule['letter']
            if letter == '-':
                letter = ''
            entry = self.letters_map[letter]
            letter_index = entry[0]  # entry[1] is the byte offset

            raw_line = normalize_raw(rule['raw_line'])
            from_year = rule['from_year']
            to_year = rule['to_year']
            in_month = rule['in_month']
            on_day_of_week = rule['on_day_of_week']
            on_day_of_month = rule['on_day_of_month']
            at_time_code = rule['at_time_code']
            at_time_modifier = rule['at_time_modifier']
            delta_code = rule['delta_code_encoded']
            letter_comment = f'"{letter}"'

            rule_items_string += f"""\
\t// {raw_line}
\t{{
\t\tFromYear: {from_year},
\t\tToYear: {to_year},
\t\tInMonth: {in_month},
\t\tOnDayOfWeek: {on_day_of_week},
\t\tOnDayOfMonth: {on_day_of_month},
\t\tAtTimeCode: {at_time_code},
\t\tAtTimeModifier: {at_time_modifier}, // {at_time_modifier_comment}
\t\tDeltaCode: {delta_code}, // {delta_code_comment}
\t\tLetterIndex: {letter_index}, // {letter_comment}
\t}},
"""
        return rule_items_string

    def _generate_policies_string(self, policy_index_map: IndexSizeMap) -> str:
        zone_policies_string = """\
var ZonePolicies = []zoneinfo.ZonePolicy{{
"""

        for policy_name, value in policy_index_map.items():
            index = value[0]
            rule_index = value[1]
            size = value[2]
            if policy_name == "":
                policy_name = "(None)"
            zone_policies_string += f"""\
\t{rule_index, size}, // {index}: Policy {policy_name}
"""
        zone_policies_string += """\
}}
"""
        return zone_policies_string

    # ------------------------------------------------------------------------
    # Zone Infos
    # ------------------------------------------------------------------------

    def _generate_infos(self) -> str:
        (num_eras, info_items) = self._generate_info_items(self.zones_map)
        link_items = self._generate_link_items(self.links_map)
        removed_info_items = _render_comments_map(self.removed_zones)
        # notable_info_items = _render_comments_map(self.notable_zones)
        notable_info_items = _render_merged_comments_map(
            self.merged_notable_zones)
        removed_link_items = _render_comments_map(self.removed_links)
        notable_link_items = _render_comments_map(self.notable_links)

        format_data = '" +\n\t\t"'.join(self.formats_map.keys())
        format_offsets = _render_offsets(
            [x[1] for x in self.formats_map.values()]
        )

        name_data = '" +\n\t\t"'.join(self.names_map.keys())
        name_offsets = _render_offsets(
            [x[1] for x in self.names_map.values()]
        )

        return self.ZONE_INFOS_FILE.format(
            invocation=self.invocation,
            tz_version=self.tz_version,
            tz_files=self.tz_files,
            dbNamespace=self.db_namespace,
            start_year=self.start_year,
            until_year=self.until_year,
            numInfos=len(self.zones_map),
            numEras=num_eras,
            infoItems=info_items,
            numLinks=len(self.links_map),
            linkItems=link_items,
            numRemovedInfos=len(self.removed_zones),
            removedInfoItems=removed_info_items,
            numNotableInfos=len(self.notable_zones),
            notableInfoItems=notable_info_items,
            numRemovedLinks=len(self.removed_links),
            removedLinkItems=removed_link_items,
            numNotableLinks=len(self.notable_links),
            notableLinkItems=notable_link_items,
            formatData=format_data,
            formatOffsets=format_offsets,
            nameData=name_data,
            nameOffsets=name_offsets,
        )

    def _generate_info_items(self, zones_map: ZonesMap) -> Tuple[int, str]:
        info_items = ''
        num_eras = 0
        for name, eras in sorted(self.zones_map.items()):
            info_items += self._generate_info_item(name, eras)
            num_eras += len(eras)
        return (num_eras, info_items)

    # TODO: Remove {link -> map} array
    def _generate_link_items(self, links_map: LinksMap) -> str:
        link_items = ''
        for link_name, zone_name in sorted(links_map.items()):
            link_normalized_name = normalize_name(link_name)
            zone_normalized_name = normalize_name(zone_name)
            start_year = self.start_year
            until_year = self.until_year
            link_id = self.link_ids[link_name]
            name_index = self.names_map[link_name][0]

            link_items += f"""\
// Link: {link_name} -> {zone_name}
var Zone{link_normalized_name} = zoneinfo.ZoneInfo{{
\tNameIndex: {name_index}, // "{link_name}"
\tZoneID: 0x{link_id:08x},
\tStartYear: {start_year},
\tUntilYear: {until_year},
\tEras: nil,
\tTarget: &Zone{zone_normalized_name},
}}

"""
        return link_items

    def _generate_info_item(
        self, zone_name: str, eras: List[ZoneEraRaw],
    ) -> str:
        era_items = ''
        for era in eras:
            era_items += self._generate_era_item(era)

        name_index = self.names_map[zone_name][0]

        zone_normalized_name = normalize_name(zone_name)
        zone_id = self.zone_ids[zone_name]
        num_eras = len(eras)
        return f"""\
// ---------------------------------------------------------------------------
// Zone name: {zone_name}
// Era count: {num_eras}
// ---------------------------------------------------------------------------

var ZoneEra{zone_normalized_name} = []zoneinfo.ZoneEra{{
{era_items}
}}

var Zone{zone_normalized_name} = zoneinfo.ZoneInfo{{
\tZoneID: 0x{zone_id:08x},
\tNameIndex: {name_index}, // "{zone_name}"
\tStartYear: {self.start_year},
\tUntilYear: {self.until_year},
\tEras: ZoneEra{zone_normalized_name},
\tTarget: nil,
}}

"""

    def _generate_era_item(self, era: ZoneEraRaw) -> str:
        policy_name = era['rules']
        if policy_name in ['-', ':']:
            zone_policy = "nil"
        else:
            zone_policy = f'&ZonePolicy{normalize_name(policy_name)}'
        delta_code_comment = _get_era_delta_code_comment(
            offset_seconds=era['offset_seconds_truncated'],
            delta_seconds=era['rules_delta_seconds_truncated'],
            scope='extended',
        )
        until_time_modifier_comment = _get_time_modifier_comment(
            time_seconds=era['until_seconds_truncated'],
            suffix=era['until_time_suffix'],
        )

        # Find the index for the 'format' field.
        format_short = era['format_short']
        entry = self.formats_map[format_short]
        format_index = entry[0]  # entry[1] is the byte offset

        return self.ZONE_ERA_ITEM.format(
            raw_line=normalize_raw(era['raw_line']),
            zone_policy=zone_policy,
            format_index=format_index,
            format_comment=f'"{format_short}"',
            offset_code=era['offset_code'],
            delta_code=era['delta_code_encoded'],
            delta_code_comment=delta_code_comment,
            until_year=era['until_year'],
            until_month=era['until_month'],
            until_day=era['until_day'],
            until_time_code=era['until_time_code'],
            until_time_modifier=era['until_time_modifier'],
            until_time_modifier_comment=until_time_modifier_comment,
        )

    # ------------------------------------------------------------------------
    # Zone Registry
    # ------------------------------------------------------------------------

    def _generate_registry(self) -> str:
        zone_and_link_items = self._generate_zone_and_link_registry_items()
        zone_and_link_ids = self._generate_zone_and_link_ids()

        return self.ZONE_REGISTRY_FILE.format(
            invocation=self.invocation,
            tz_version=self.tz_version,
            tz_files=self.tz_files,
            dbNamespace=self.db_namespace,
            numZones=len(self.zones_map),
            numLinks=len(self.links_map),
            numZonesAndLinks=len(self.zones_and_links),
            zoneAndLinkItems=zone_and_link_items,
            zoneAndLinkIds=zone_and_link_ids,
        )

    def _generate_zone_and_link_registry_items(self) -> str:
        """Generate a map of (zone_name -> zoneInfo), for all zones and links,
        sorted by name.
        """
        zone_and_link_registry_items = ''
        for zone_name in sorted(
            self.zones_and_links,
            key=lambda x: self.zone_and_link_ids[x],
        ):
            normalized_name = normalize_name(zone_name)
            zone_id = self.zone_and_link_ids[zone_name]
            target_name = self.links_map.get(zone_name)
            if target_name:
                desc_name = f'{zone_name} -> {target_name}'
            else:
                desc_name = zone_name

            zone_and_link_registry_items += f"""\
\t&Zone{normalized_name}, // 0x{zone_id:08x}, {desc_name}
"""
        return zone_and_link_registry_items

    def _generate_zone_and_link_ids(self) -> str:
        """Generate a list of constants of the form ZoneID{zoneName},
        sorted by name.
        """
        s = ''
        for name in sorted(self.zones_and_links):
            zone_id = self.zone_and_link_ids.get(name)
            if zone_id is None:
                raise Exception(f'Zone or Link "{name}" not found')
            normalized_name = normalize_name(name)
            s += f"""\
\tZoneID{normalized_name} uint32 = 0x{zone_id:08x} // {name}
"""
        return s


def _render_comments_map(comments: CommentsMap, indent: str = '') -> str:
    """Convert the CommentsMap into a Python comment. Print the name and list
    of reasons one a single line, or multiple lines, like this:

    // Name1 {reason}
    //
    // Name2 {
    //   reason1,
    //   reason2,
    // }
    """
    comment = ''
    for name, reasons in sorted(comments.items()):
        if len(reasons) <= 1:
            comment += f"// {indent}{name} {{{next(iter(reasons))}}}\n"
        else:
            comment += f"// {indent}{name} {{\n"
            for reason in reasons:
                comment += f'// {indent}  {reason},\n'
            comment += f"// {indent}}}\n"
    return comment


def _render_merged_comments_map(merged_comments: MergedCommentsMap) -> str:
    """Converts MergedCommentsMap for zones into a C++ comment. Includes the
    comments for zones, as well as any comments in the referenced policies.

    // Name1 {reason}
    //
    // Name2 {
    //   reason1,
    //   reason2,
    // }
    //
    // Name3 {
    //   reason1,
    //   reason2,
    //   Policy1 {reason11}
    //   Policy2 {
    //     reason21,
    //     reason22,
    //   }
    // }
    """
    comment = ''
    for name, reasons in sorted(merged_comments.items()):
        if len(reasons) == 0:
            continue

        # If only a single comment, and the comment is a simple string,
        # render it in a single line.
        reason = next(iter(reasons))
        if len(reasons) == 1 and isinstance(reason, str):
            comment += f"// {name} {{{reason}}}\n"
            continue

        # Otherwise, render the comments using multiple lines deliminted by ( )
        comment += f"// {name} {{\n"
        for reason in reasons:
            if isinstance(reason, str):
                comment += f'//   {reason},\n'
            else:
                comment += _render_comments_map(reason, '  ')
        comment += "// }\n"
    return comment


def _get_time_modifier_comment(
    time_seconds: int,
    suffix: str,
) -> str:
    """Create the comment that explains how the until_time_code or at_time_code
    was calculated.
    """
    if suffix == 'w':
        comment = 'SuffixW'
    elif suffix == 's':
        comment = 'SuffixS'
    else:
        comment = 'SuffixU'
    remaining_time_minutes = time_seconds % 900 // 60
    comment += f' + minute={remaining_time_minutes}'
    return comment


def _get_era_delta_code_comment(
    offset_seconds: int,
    delta_seconds: int,
    scope: str,
) -> str:
    """Create the comment that explains how the ZoneEra delta_code[_encoded] was
    calculated.
    """
    offset_minute = offset_seconds % 900 // 60
    delta_minutes = delta_seconds // 60
    if scope == 'extended':
        return (
            f"((offset_minute={offset_minute}) << 4) + "
            f"((delta_minutes={delta_minutes})/15 + 4)"
        )
    else:
        return f"(delta_minutes={delta_minutes})/15"


def _get_rule_delta_code_comment(
    delta_seconds: int,
    scope: str,
) -> str:
    """Create the comment that explains how the ZoneRule delta_code[_encoded]
    was calculated.
    """
    delta_minutes = delta_seconds // 60
    if scope == 'extended':
        return f"(delta_minutes={delta_minutes})/15 + 4"
    else:
        return f"(delta_minutes={delta_minutes})/15"


def _render_offsets(offsets: Iterable[int], prefix: str = '\t\t') -> str:
    """Return a comma-separated list integers as a string suitable for Golang,
    with a newline added every 10 elements for readability. The logic to
    correctly handle trailing commas, spaces, and newlines properly was trickier
    than I thought it would be.
    """
    items_per_line = 10
    count = 0
    s = ''
    for n in offsets:
        if count == 0:
            s += f'{prefix}{n}'
        elif count % items_per_line == 0:
            s += f',\n{prefix}{n}'
        else:
            s += f', {n}'
        count += 1

    # Add terminating delimiters
    if count == 0:
        pass
    else:
        s += ','
    return s
