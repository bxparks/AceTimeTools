# Copyright 2023 Brian T. Park
#
# MIT License
"""
Generate the 'zone_infos.py' and 'zone_policies.py' files for Go lang.
"""

import logging
import os
from typing import Iterable
from typing import List
from typing import Tuple

from acetimetools.data_types.at_types import ZoneEraRaw
from acetimetools.data_types.at_types import ZoneRuleRaw
from acetimetools.data_types.at_types import ZonesMap
from acetimetools.data_types.at_types import PoliciesMap
from acetimetools.data_types.at_types import CommentsMap
from acetimetools.data_types.at_types import MergedCommentsMap
from acetimetools.data_types.at_types import ZoneInfoDatabase
from acetimetools.data_types.at_types import IndexSizeMap
from acetimetools.transformer.transformer import normalize_name
from acetimetools.transformer.transformer import normalize_raw
from acetimetools.generator.byteutils import convert_to_go_string
from acetimetools.generator.byteutils import write_u8
from acetimetools.generator.byteutils import write_u16
from acetimetools.generator.byteutils import write_u32


class GoGenerator:
    """Generate Go lang files (zone_infos.go, zone_policies.go) which are
    used by the ZoneProcessor class.
    """

    ZONE_POLICIES_FILE = """\
// This file was generated by the following script:
//
//   $ {invocation}
//
// using the TZ Database files
//
//   {tz_files}
//
// from https://github.com/eggert/tz/releases/tag/{tz_version}
//
// DO NOT EDIT

package {dbNamespace}

import (
\t"github.com/bxparks/AceTimeGo/zoneinfo"
)

// ---------------------------------------------------------------------------
// String constants.
// ---------------------------------------------------------------------------

const (
\t// All ZoneRule.Letter entries concatenated together.
\tLetterData = "{letterData}"
)

var (
\t// Byte offset into LetterData for each index. The actual Letter string
\t// at index `i` given by the `ZoneRule.Letter` field is
\t// `LetterData[LetterOffsets[i]:LetterOffsets[i+1]]`.
\tLetterOffsets = []uint8{{
{letterOffsets}
\t}}
)

// ---------------------------------------------------------------------------
// ZoneRuleRecords is a concatenated array of zoneinfo.ZoneInfoRecord objects
// from all ZonePolicyRecords.
//
// Supported zone policies: {numPolicies}
// numRules: {numRules}
// ---------------------------------------------------------------------------

var ZoneRuleRecords = []zoneinfo.ZoneRuleRecord{{
{zoneRules}
}}

const ZoneRuleCount = {zoneRuleCount}

const ZoneRuleChunkSize = {zoneRuleChunkSize}

// ZoneRulesData contains the ZoneRuleRecords data as a hex encoded string.
const ZoneRulesData = {zoneRulesData}

// ---------------------------------------------------------------------------
// ZonePolicyRecords contain indexes into the ZoneRuleRecords.
// Supported zone policies: {numPolicies}
// ---------------------------------------------------------------------------

var ZonePolicyRecords = []zoneinfo.ZonePolicyRecord{{
{zonePolicies}
}}

const ZonePolicyCount = {zonePolicyCount}

const ZonePolicyChunkSize = {zonePolicyChunkSize}

// ZonePoliciesData contains the ZonePolicyRecords data as a hex encoded string.
const ZonePoliciesData = {zonePoliciesData}

// ---------------------------------------------------------------------------
// Unsupported zone policies: {numRemovedPolicies}
// ---------------------------------------------------------------------------

{removedPolicyItems}

// ---------------------------------------------------------------------------
// Notable zone policies: {numNotablePolicies}
// ---------------------------------------------------------------------------

{notablePolicyItems}

"""

    ZONE_INFOS_FILE = """\
// This file was generated by the following script:
//
//   $ {invocation}
//
// using the TZ Database files
//
//   {tz_files}
//
// from https://github.com/eggert/tz/releases/tag/{tz_version}
//
// DO NOT EDIT

package {dbNamespace}

import (
\t"github.com/bxparks/AceTimeGo/zoneinfo"
)

// ---------------------------------------------------------------------------
// String constants.
// ---------------------------------------------------------------------------

const (
\t// All ZoneEra.Format entries concatenated together.
\tFormatData = "{formatData}"

\t// All ZoneInfo.Name entries concatenated togther.
\tNameData = "{nameData}"
)

var (
\t// Byte offset into FormatData for each index. The actual Format string
\t// at index `i` given by the `ZoneEra.Format` field is
\t// `FormatData[FormatOffsets[i]:FormatOffsets[i+1]]`.
\tFormatOffsets = []uint16{{
{formatOffsets}
}}

\t// Byte offset into NameData for each index. The actual Letter string
\t// at index `i` given by the `ZoneRule.Name` field is
\t// `NameData[NameOffsets[i]:NameOffsets[i+1]]`.
\tNameOffsets = []uint16{{
{nameOffsets}
\t}}
)

// ---------------------------------------------------------------------------
// ZoneEraRecords is an array of zoneinfo.ZoneEraRecord items concatenated
// together.
//
// Supported zones: {numInfos}
// numEras: {numEras}
// ---------------------------------------------------------------------------

var ZoneEraRecords = []zoneinfo.ZoneEraRecord{{
{zoneEras}
}}

const ZoneEraCount = {zoneEraCount}

const ZoneEraChunkSize = {zoneEraChunkSize}

// ZoneErasData contains the ZoneEraRecords data as a hex encoded string.
const ZoneErasData = {zoneErasData}

// ---------------------------------------------------------------------------
// ZoneInfoRecords is an array of zoneinfo.ZoneInfoRecord items concatenated
// together.
//
// Total: {numZonesAndLinks} ({numInfos} zones, {numLinks} links)
// ---------------------------------------------------------------------------

var ZoneInfoRecords = []zoneinfo.ZoneInfoRecord{{
{zoneInfos}
}}

const ZoneInfoCount = {zoneInfoCount}

const ZoneInfoChunkSize = {zoneInfoChunkSize}

// ZoneInfosData contains the ZoneInfoRecords data as a hex encoded string.
const ZoneInfosData = {zoneInfosData}

// ---------------------------------------------------------------------------
// Unsuported zones: {numRemovedInfos}
// ---------------------------------------------------------------------------

{removedInfoItems}

// ---------------------------------------------------------------------------
// Notable zones: {numNotableInfos}
// ---------------------------------------------------------------------------

{notableInfoItems}

// ---------------------------------------------------------------------------
// Unsuported links: {numRemovedLinks}
// ---------------------------------------------------------------------------

{removedLinkItems}

// ---------------------------------------------------------------------------
// Notable links: {numNotableLinks}
// ---------------------------------------------------------------------------

{notableLinkItems}
"""

    ZONE_REGISTRY_FILE = """\
// This file was generated by the following script:
//
//   $ {invocation}
//
// using the TZ Database files
//
//   {tz_files}
//
// from https://github.com/eggert/tz/releases/tag/{tz_version}
//
// DO NOT EDIT

package {dbNamespace}

import (
\t"github.com/bxparks/AceTimeGo/zoneinfo"
)

// ---------------------------------------------------------------------------
// Zone Context
// ---------------------------------------------------------------------------

const TzDatabaseVersion string = "{tz_version}"

var RecordContext = zoneinfo.ZoneRecordContext{{
\tTzDatabaseVersion: TzDatabaseVersion,
\tStartYear: {startYear},
\tUntilYear: {untilYear},
\tLetterData: LetterData,
\tLetterOffsets: LetterOffsets,
\tFormatData: FormatData,
\tFormatOffsets: FormatOffsets,
\tNameData: NameData,
\tNameOffsets: NameOffsets,
\tZoneRuleRecords: ZoneRuleRecords,
\tZonePolicyRecords: ZonePolicyRecords,
\tZoneEraRecords: ZoneEraRecords,
\tZoneInfoRecords: ZoneInfoRecords,
}}

var DataContext = zoneinfo.ZoneDataContext{{
\tTzDatabaseVersion: TzDatabaseVersion,
\tStartYear: {startYear},
\tUntilYear: {untilYear},
\tLetterData: LetterData,
\tLetterOffsets: LetterOffsets,
\tFormatData: FormatData,
\tFormatOffsets: FormatOffsets,
\tNameData: NameData,
\tNameOffsets: NameOffsets,
\tZoneRuleChunkSize: ZoneRuleChunkSize,
\tZonePolicyChunkSize: ZonePolicyChunkSize,
\tZoneEraChunkSize: ZoneEraChunkSize,
\tZoneInfoChunkSize: ZoneInfoChunkSize,
\tZoneRuleCount: ZoneRuleCount,
\tZonePolicyCount: ZonePolicyCount,
\tZoneEraCount: ZoneEraCount,
\tZoneInfoCount: ZoneInfoCount,
\tZoneRulesData: ZoneRulesData,
\tZonePoliciesData: ZonePoliciesData,
\tZoneErasData: ZoneErasData,
\tZoneInfosData: ZoneInfosData,
}}

// ---------------------------------------------------------------------------
// Zone IDs. Unique stable uint32 identifier for each zone which can be given to
// ZoneManager.NewTimeZoneFromID(). Useful for microcontroller environments
// where saving variable length strings is more difficult than a fixed width
// integer.
//
// Total: {numZonesAndLinks} ({numZones} zones, {numLinks} links)
// ---------------------------------------------------------------------------

const (
{zoneAndLinkIds}
)

// ---------------------------------------------------------------------------
// Zone Indexes. Index into the ZoneInfoRecords array. Intended for unit tests
// which need direct access to the zoneinfo.ZoneInfo struct.
//
// Total: {numZonesAndLinks} ({numZones} zones, {numLinks} links)
// ---------------------------------------------------------------------------

const (
{zoneAndLinkIndexes}
)
"""

    ZONE_INFOS_FILE_NAME = 'zone_infos.go'
    ZONE_POLICIES_FILE_NAME = 'zone_policies.go'
    ZONE_REGISTRY_FILE_NAME = 'zone_registry.go'

    def __init__(
        self,
        invocation: str,
        db_namespace: str,
        zidb: ZoneInfoDatabase,
    ):
        wrapped_invocation = '\n//     --'.join(invocation.split(' --'))
        wrapped_tzfiles = '\n//   '.join(zidb['tz_files'])
        self.invocation = wrapped_invocation
        self.tz_files = wrapped_tzfiles
        self.db_namespace = db_namespace
        self.tz_version = zidb['tz_version']
        self.start_year = zidb['start_year']
        self.until_year = zidb['until_year']
        self.zones_map = zidb['zones_map']
        self.links_map = zidb['links_map']
        self.policies_map = zidb['policies_map']
        self.removed_zones = zidb['removed_zones']
        self.removed_links = zidb['removed_links']
        self.removed_policies = zidb['removed_policies']
        self.notable_zones = zidb['notable_zones']
        self.merged_notable_zones = zidb['merged_notable_zones']
        self.notable_links = zidb['notable_links']
        self.notable_policies = zidb['notable_policies']
        self.zone_ids = zidb['zone_ids']
        self.link_ids = zidb['link_ids']
        self.letters_map = zidb['go_letters_map']
        self.formats_map = zidb['go_formats_map']
        self.names_map = zidb['go_names_map']
        self.zone_and_link_index_map = zidb['go_zone_and_link_index_map']
        self.policy_index_size_map = zidb['go_policy_index_size_map']
        self.num_rules = zidb['go_rule_count']
        self.info_index_size_map = zidb['go_info_index_size_map']
        self.num_eras = zidb['go_era_count']

        self.zones_and_links = (
            list(self.zones_map.keys())
            + list(self.links_map.keys())
        )
        self.zone_and_link_ids = self.zone_ids.copy()
        self.zone_and_link_ids.update(self.link_ids)

    def generate_files(self, output_dir: str) -> None:
        self._write_file(output_dir, self.ZONE_POLICIES_FILE_NAME,
                         self._generate_policies())

        self._write_file(output_dir, self.ZONE_INFOS_FILE_NAME,
                         self._generate_infos())

        self._write_file(output_dir, self.ZONE_REGISTRY_FILE_NAME,
                         self._generate_registry())

    def _write_file(self, output_dir: str, filename: str, content: str) -> None:
        full_filename = os.path.join(output_dir, filename)
        with open(full_filename, 'w', encoding='utf-8') as output_file:
            print(content, end='', file=output_file)
        logging.info("Created %s", full_filename)

    # ------------------------------------------------------------------------
    # Zone Policies
    # ------------------------------------------------------------------------

    def _generate_policies(self) -> str:
        zone_rules_string = self._generate_rules_string(self.policies_map)
        zone_rules_data, chunk_size, count = self._generate_rules_data(
            self.policies_map)
        zone_rules_data_string = convert_to_go_string(
            zone_rules_data, chunk_size, '\t\t')
        zone_rule_chunk_size = chunk_size
        zone_rule_count = count

        zone_policies_string = self._generate_policies_string(
            self.policy_index_size_map)
        zone_policies_data, chunk_size, count = self._generate_policies_data(
            self.policy_index_size_map)
        zone_policies_data_string = convert_to_go_string(
            zone_policies_data, chunk_size, '\t\t')
        zone_policy_chunk_size = chunk_size
        zone_policy_count = count

        removed_policy_items = _render_comments_map(self.removed_policies)
        notable_policy_items = _render_comments_map(self.notable_policies)

        letter_data = '" +\n\t\t"'.join(self.letters_map.keys())
        letter_offsets = _render_offsets(
            [x[1] for x in self.letters_map.values()]
        )

        return self.ZONE_POLICIES_FILE.format(
            invocation=self.invocation,
            tz_version=self.tz_version,
            tz_files=self.tz_files,
            dbNamespace=self.db_namespace,
            numPolicies=len(self.policies_map),
            numRules=self.num_rules,
            zoneRules=zone_rules_string,
            zoneRulesData=zone_rules_data_string,
            zoneRuleChunkSize=zone_rule_chunk_size,
            zoneRuleCount=zone_rule_count,
            zonePolicies=zone_policies_string,
            zonePoliciesData=zone_policies_data_string,
            zonePolicyChunkSize=zone_policy_chunk_size,
            zonePolicyCount=zone_policy_count,
            numRemovedPolicies=len(self.removed_policies),
            removedPolicyItems=removed_policy_items,
            numNotablePolicies=len(self.notable_policies),
            notablePolicyItems=notable_policy_items,
            letterData=letter_data,
            letterOffsets=letter_offsets,
        )

    def _generate_rules_string(self, policies_map: PoliciesMap) -> str:
        zone_rules_string = ''
        rule_index = 0
        for policy_name, rules in sorted(policies_map.items()):
            zone_rules_string += self._generate_rule_items_string(
                policy_name, rule_index, rules)
            rule_index += len(rules)
            zone_rules_string += '\n'
        return zone_rules_string

    def _generate_rule_items_string(
        self,
        policy_name: str,
        rule_index: int,
        rules: List[ZoneRuleRaw]
    ) -> str:
        rule_items_string = f"""\
\t// ---------------------------------------------------------------------------
\t// PolicyName: {policy_name}
\t// RuleIndex: {rule_index}
\t// RuleCount: {len(rules)}
\t// ---------------------------------------------------------------------------

"""
        for rule in rules:
            at_time_modifier_comment = _get_time_modifier_comment(
                time_seconds=rule['at_seconds_truncated'],
                suffix=rule['at_time_suffix'],
            )
            delta_code_comment = _get_rule_delta_code_comment(
                delta_seconds=rule['delta_seconds_truncated'],
                scope='extended',  # AceTimeGo supports only extended
            )

            # Find the index for the 'letter' field.
            letter = rule['letter']
            if letter == '-':
                letter = ''
            entry = self.letters_map[letter]
            letter_index = entry[0]  # entry[1] is the byte offset

            raw_line = normalize_raw(rule['raw_line'])
            from_year = rule['from_year']
            to_year = rule['to_year']
            in_month = rule['in_month']
            on_day_of_week = rule['on_day_of_week']
            on_day_of_month = rule['on_day_of_month']
            at_time_code = rule['at_time_code']
            at_time_modifier = rule['at_time_modifier']
            delta_code = rule['delta_code_encoded']
            letter_comment = f'"{letter}"'

            rule_items_string += f"""\
\t// {raw_line}
\t{{
\t\tFromYear: {from_year},
\t\tToYear: {to_year},
\t\tInMonth: {in_month},
\t\tOnDayOfWeek: {on_day_of_week},
\t\tOnDayOfMonth: {on_day_of_month},
\t\tAtTimeCode: {at_time_code},
\t\tAtTimeModifier: {at_time_modifier}, // {at_time_modifier_comment}
\t\tDeltaCode: {delta_code}, // {delta_code_comment}
\t\tLetterIndex: {letter_index}, // {letter_comment}
\t}},
"""
        return rule_items_string

    def _generate_rules_data(
        self, policies_map: PoliciesMap
    ) -> Tuple[bytearray, int, int]:
        """Return the bytearray encoding of the ZoneRuleRecords, and the size of
        each encoded ZoneRule.
        """

        chunk_size = 11
        data = bytearray()
        count = 0
        for policy_name, rules in sorted(policies_map.items()):
            count += len(rules)
            for rule in rules:
                self._generate_rule_data(data, rule)
        return data, chunk_size, count

    def _generate_rule_data(self, data: bytearray, rule: ZoneRuleRaw) -> None:
        # Find the index for the 'letter' field.
        letter = rule['letter']
        if letter == '-':
            letter = ''
        entry = self.letters_map[letter]
        letter_index = entry[0]  # entry[1] is the byte offset

        # chunk_size = 11 bytes
        write_u16(data, rule['from_year'])
        write_u16(data, rule['to_year'])
        write_u8(data, rule['in_month'])
        write_u8(data, rule['on_day_of_week'])
        write_u8(data, rule['on_day_of_month'])
        write_u8(data, rule['at_time_code'])
        write_u8(data, rule['at_time_modifier'])
        write_u8(data, rule['delta_code_encoded'])
        write_u8(data, letter_index)

    def _generate_policies_string(
        self, policy_index_size_map: IndexSizeMap
    ) -> str:
        zone_policies_string = ''
        for policy_name, indexes in policy_index_size_map.items():
            index = indexes[0]
            rule_index = indexes[1]
            rule_count = indexes[2]
            if policy_name == "":
                policy_name = "(None)"
            zone_policies_string += f"""\
\t{{RuleIndex: {rule_index}, RuleCount: {rule_count}}}, \
// {index}: PolicyName: {policy_name}
"""
        return zone_policies_string

    def _generate_policies_data(
        self, policy_index_size_map: IndexSizeMap
    ) -> Tuple[bytearray, int, int]:
        """Return the bytearray encoding of the ZonePolicyRecords, and the size
        of each encoded ZonePolicy.
        """
        chunk_size = 4
        data = bytearray()
        for policy_name, indexes in policy_index_size_map.items():
            rule_index = indexes[1]
            rule_count = indexes[2]
            write_u16(data, rule_index)
            write_u16(data, rule_count)
        return data, chunk_size, len(policy_index_size_map)

    # ------------------------------------------------------------------------
    # Zone Infos
    # ------------------------------------------------------------------------

    def _generate_infos(self) -> str:
        zone_eras_string = self._generate_eras_string(self.zones_map)
        zone_eras_data, chunk_size, count = self._generate_eras_data(
            self.zones_map)
        zone_eras_data_string = convert_to_go_string(
            zone_eras_data, chunk_size, '\t\t')
        zone_era_chunk_size = chunk_size
        zone_era_count = count

        zone_infos_string = self._generate_infos_string()
        zone_infos_data, chunk_size, count = self._generate_infos_data()
        zone_infos_data_string = convert_to_go_string(
            zone_infos_data, chunk_size, '\t\t')
        zone_info_chunk_size = chunk_size
        zone_info_count = count

        removed_info_items = _render_comments_map(self.removed_zones)
        # notable_info_items = _render_comments_map(self.notable_zones)
        notable_info_items = _render_merged_comments_map(
            self.merged_notable_zones)
        removed_link_items = _render_comments_map(self.removed_links)
        notable_link_items = _render_comments_map(self.notable_links)

        format_data = '" +\n\t\t"'.join(self.formats_map.keys())
        format_offsets = _render_offsets(
            [x[1] for x in self.formats_map.values()]
        )

        name_data = '" +\n\t\t"'.join(self.names_map.keys())
        name_offsets = _render_offsets(
            [x[1] for x in self.names_map.values()]
        )

        return self.ZONE_INFOS_FILE.format(
            invocation=self.invocation,
            tz_version=self.tz_version,
            tz_files=self.tz_files,
            dbNamespace=self.db_namespace,
            start_year=self.start_year,
            until_year=self.until_year,
            numEras=self.num_eras,
            numInfos=len(self.zones_map),
            numLinks=len(self.links_map),
            numZonesAndLinks=len(self.zones_and_links),
            zoneEras=zone_eras_string,
            zoneErasData=zone_eras_data_string,
            zoneEraChunkSize=zone_era_chunk_size,
            zoneEraCount=zone_era_count,
            zoneInfos=zone_infos_string,
            zoneInfosData=zone_infos_data_string,
            zoneInfoChunkSize=zone_info_chunk_size,
            zoneInfoCount=zone_info_count,
            numRemovedInfos=len(self.removed_zones),
            removedInfoItems=removed_info_items,
            numNotableInfos=len(self.notable_zones),
            notableInfoItems=notable_info_items,
            numRemovedLinks=len(self.removed_links),
            removedLinkItems=removed_link_items,
            numNotableLinks=len(self.notable_links),
            notableLinkItems=notable_link_items,
            formatData=format_data,
            formatOffsets=format_offsets,
            nameData=name_data,
            nameOffsets=name_offsets,
        )

    def _generate_eras_string(self, zones_map: ZonesMap) -> str:
        zone_eras_string = ''
        era_index = 0
        for zone_name, eras in sorted(self.zones_map.items()):
            zone_eras_string += self._generate_era_items_string(
                zone_name, era_index, eras, self.policy_index_size_map)
            era_index += len(eras)
        return zone_eras_string

    def _generate_era_items_string(
        self,
        zone_name: str,
        era_index: int,
        eras: List[ZoneEraRaw],
        policy_index_size_map: IndexSizeMap,
    ) -> str:
        era_items_string = f"""\
\t// ---------------------------------------------------------------------------
\t// ZoneName: {zone_name}
\t// EraIndex: {era_index}
\t// EraCount: {len(eras)}
\t// ---------------------------------------------------------------------------

"""
        for era in eras:
            policy_name = era['rules']
            if policy_name in ['-', ':']:
                policy_name = ""
            policy_index = policy_index_size_map[policy_name][0]
            if policy_name == "":
                policy_name = "(none)"

            delta_code_comment = _get_era_delta_code_comment(
                offset_seconds=era['offset_seconds_truncated'],
                delta_seconds=era['rules_delta_seconds_truncated'],
                scope='extended',
            )
            until_time_modifier_comment = _get_time_modifier_comment(
                time_seconds=era['until_seconds_truncated'],
                suffix=era['until_time_suffix'],
            )

            # Find the index for the 'format' field.
            format_short = era['format_short']
            entry = self.formats_map[format_short]
            format_index = entry[0]  # (index, offset)

            raw_line = normalize_raw(era['raw_line'])
            format_comment = f'"{format_short}"'
            offset_code = era['offset_code']
            delta_code = era['delta_code_encoded']
            until_year = era['until_year']
            until_month = era['until_month']
            until_day = era['until_day']
            until_time_code = era['until_time_code']
            until_time_modifier = era['until_time_modifier']

            era_items_string += f"""\
\t// {raw_line}
\t{{
\t\tPolicyIndex: {policy_index}, // PolicyName: {policy_name}
\t\tFormatIndex: {format_index}, // {format_comment}
\t\tOffsetCode: {offset_code},
\t\tDeltaCode: {delta_code}, // {delta_code_comment}
\t\tUntilYear: {until_year},
\t\tUntilMonth: {until_month},
\t\tUntilDay: {until_day},
\t\tUntilTimeCode: {until_time_code},
\t\tUntilTimeModifier: {until_time_modifier}, // {until_time_modifier_comment}
\t}},
"""
            era_items_string += '\n'

        return era_items_string

    def _generate_eras_data(
        self, zones_map: ZonesMap
    ) -> Tuple[bytearray, int, int]:
        count = 0
        chunk_size = 11
        data = bytearray()
        for zone_name, eras in sorted(self.zones_map.items()):
            count += len(eras)
            for era in eras:
                self._generate_era_data(data, era)
        return data, chunk_size, count

    def _generate_era_data(self, data: bytearray, era: ZoneEraRaw) -> None:
        policy_name = era['rules']
        if policy_name in ['-', ':']:
            policy_name = ""
        policy_index = self.policy_index_size_map[policy_name][0]

        # Find the index for the 'format' field.
        format_short = era['format_short']
        entry = self.formats_map[format_short]
        format_index = entry[0]  # (index, offset)

        offset_code = era['offset_code']
        delta_code = era['delta_code_encoded']
        until_year = era['until_year']
        until_month = era['until_month']
        until_day = era['until_day']
        until_time_code = era['until_time_code']
        until_time_modifier = era['until_time_modifier']

        # chunk size = 11 bytes
        write_u16(data, format_index)
        write_u8(data, policy_index)
        write_u8(data, offset_code)
        write_u8(data, delta_code)
        write_u16(data, until_year)
        write_u8(data, until_month)
        write_u8(data, until_day)
        write_u8(data, until_time_code)
        write_u8(data, until_time_modifier)

    def _generate_infos_string(self) -> str:
        zone_infos_string = ''
        combined_index = 0
        # Loop over all zones and links, sorted by zoneId/linkId.
        for name in self.zone_and_link_index_map:
            target_name = self.links_map.get(name)
            if target_name is None:  # Zone
                desc_name = f'Zone {name}'
                zone_id = self.zone_ids[name]
                indexes = self.info_index_size_map[name]
                era_index = indexes[1]
                era_count = indexes[2]
                era_count_desc = ''
                target_index = 0
                target_desc = ''
            else:  # Link
                desc_name = f'Link {name} -> {target_name}'
                zone_id = self.link_ids[name]
                era_index = 0
                era_count = 0
                era_count_desc = ' // IsLink=true'
                target_index = self.zone_and_link_index_map[target_name]
                target_desc = f' // {target_name}'
            name_index = self.names_map[name][0]

            zone_infos_string += f"""\
\t// {combined_index}: {desc_name}
\t{{
\t\tZoneID: 0x{zone_id:08x},
\t\tNameIndex: {name_index}, // "{name}"
\t\tEraIndex: {era_index},
\t\tEraCount: {era_count},{era_count_desc}
\t\tTargetIndex: {target_index},{target_desc}
\t}},
"""
            combined_index += 1
        return zone_infos_string

    def _generate_infos_data(self) -> Tuple[bytearray, int, int]:
        chunk_size = 12
        data = bytearray()
        # Loop over all zones and links, sorted by zoneId/linkId.
        for name in self.zone_and_link_index_map:
            target_name = self.links_map.get(name)
            if target_name is None:  # Zone
                zone_id = self.zone_ids[name]
                indexes = self.info_index_size_map[name]
                era_index = indexes[1]
                era_count = indexes[2]
                target_index = 0
            else:  # Link
                zone_id = self.link_ids[name]
                era_index = 0
                era_count = 0
                target_index = self.zone_and_link_index_map[target_name]
            name_index = self.names_map[name][0]

            write_u32(data, zone_id)
            write_u16(data, name_index)
            write_u16(data, era_index)
            write_u16(data, era_count)
            write_u16(data, target_index)
        return data, chunk_size, len(self.zone_and_link_index_map)

    # ------------------------------------------------------------------------
    # Zone Registry
    # ------------------------------------------------------------------------

    def _generate_registry(self) -> str:
        zone_and_link_ids_string = self._generate_zone_and_link_ids()
        zone_and_link_indexes_string = self._generate_zone_and_link_indexes()

        return self.ZONE_REGISTRY_FILE.format(
            invocation=self.invocation,
            tz_version=self.tz_version,
            tz_files=self.tz_files,
            dbNamespace=self.db_namespace,
            startYear=self.start_year,
            untilYear=self.until_year,
            numZones=len(self.zones_map),
            numLinks=len(self.links_map),
            numZonesAndLinks=len(self.zones_and_links),
            zoneAndLinkIds=zone_and_link_ids_string,
            zoneAndLinkIndexes=zone_and_link_indexes_string,
        )

    def _generate_zone_and_link_ids(self) -> str:
        """Generate a list of constants of the form ZoneID{zoneName},
        sorted by name.
        """
        s = ''
        for name in sorted(self.zones_and_links):
            zone_id = self.zone_and_link_ids.get(name)
            if zone_id is None:
                raise Exception(f'Zone or Link "{name}" not found')
            normalized_name = normalize_name(name)
            s += f"""\
\tZoneID{normalized_name} uint32 = 0x{zone_id:08x} // {name}
"""
        return s

    def _generate_zone_and_link_indexes(self) -> str:
        """Generate a list of constants of the form ZoneInfoIndex{zoneName},
        sorted by name. These are the indexes into the ZoneInfoRecords array and
        are intended for unit testing and debugging.
        """
        s = ''
        for name, index in sorted(self.zone_and_link_index_map.items()):
            zone_id = self.zone_and_link_ids.get(name)
            if zone_id is None:
                raise Exception(f'Zone or Link "{name}" not found')
            normalized_name = normalize_name(name)
            s += f"""\
\tZoneInfoIndex{normalized_name} uint16 = {index} // {name}
"""
        return s


def _render_comments_map(comments: CommentsMap, indent: str = '') -> str:
    """Convert the CommentsMap into a Python comment. Print the name and list
    of reasons one a single line, or multiple lines, like this:

    // Name1 {reason}
    //
    // Name2 {
    //   reason1,
    //   reason2,
    // }
    """
    comment = ''
    for name, reasons in sorted(comments.items()):
        if len(reasons) <= 1:
            comment += f"// {indent}{name} {{{next(iter(reasons))}}}\n"
        else:
            comment += f"// {indent}{name} {{\n"
            for reason in reasons:
                comment += f'// {indent}  {reason},\n'
            comment += f"// {indent}}}\n"
    return comment


def _render_merged_comments_map(merged_comments: MergedCommentsMap) -> str:
    """Converts MergedCommentsMap for zones into a C++ comment. Includes the
    comments for zones, as well as any comments in the referenced policies.

    // Name1 {reason}
    //
    // Name2 {
    //   reason1,
    //   reason2,
    // }
    //
    // Name3 {
    //   reason1,
    //   reason2,
    //   Policy1 {reason11}
    //   Policy2 {
    //     reason21,
    //     reason22,
    //   }
    // }
    """
    comment = ''
    for name, reasons in sorted(merged_comments.items()):
        if len(reasons) == 0:
            continue

        # If only a single comment, and the comment is a simple string,
        # render it in a single line.
        reason = next(iter(reasons))
        if len(reasons) == 1 and isinstance(reason, str):
            comment += f"// {name} {{{reason}}}\n"
            continue

        # Otherwise, render the comments using multiple lines deliminted by ( )
        comment += f"// {name} {{\n"
        for reason in reasons:
            if isinstance(reason, str):
                comment += f'//   {reason},\n'
            else:
                comment += _render_comments_map(reason, '  ')
        comment += "// }\n"
    return comment


def _get_time_modifier_comment(
    time_seconds: int,
    suffix: str,
) -> str:
    """Create the comment that explains how the until_time_code or at_time_code
    was calculated.
    """
    if suffix == 'w':
        comment = 'SuffixW'
    elif suffix == 's':
        comment = 'SuffixS'
    else:
        comment = 'SuffixU'
    remaining_time_minutes = time_seconds % 900 // 60
    comment += f' + minute={remaining_time_minutes}'
    return comment


def _get_era_delta_code_comment(
    offset_seconds: int,
    delta_seconds: int,
    scope: str,
) -> str:
    """Create the comment that explains how the ZoneEra delta_code[_encoded] was
    calculated.
    """
    offset_minute = offset_seconds % 900 // 60
    delta_minutes = delta_seconds // 60
    if scope == 'extended':
        return (
            f"((offset_minute={offset_minute}) << 4) + "
            f"((delta_minutes={delta_minutes})/15 + 4)"
        )
    else:
        return f"(delta_minutes={delta_minutes})/15"


def _get_rule_delta_code_comment(
    delta_seconds: int,
    scope: str,
) -> str:
    """Create the comment that explains how the ZoneRule delta_code[_encoded]
    was calculated.
    """
    delta_minutes = delta_seconds // 60
    if scope == 'extended':
        return f"(delta_minutes={delta_minutes})/15 + 4"
    else:
        return f"(delta_minutes={delta_minutes})/15"


def _render_offsets(offsets: Iterable[int], prefix: str = '\t\t') -> str:
    """Return a comma-separated list integers as a string suitable for Golang,
    with a newline added every 10 elements for readability. The logic to
    correctly handle trailing commas, spaces, and newlines properly was trickier
    than I thought it would be.
    """
    items_per_line = 10
    count = 0
    s = ''
    for n in offsets:
        if count == 0:
            s += f'{prefix}{n}'
        elif count % items_per_line == 0:
            s += f',\n{prefix}{n}'
        else:
            s += f', {n}'
        count += 1

    # Add terminating delimiters
    if count == 0:
        pass
    else:
        s += ','
    return s
