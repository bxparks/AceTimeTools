# Copyright 2019 Brian T. Park
#
# MIT License

"""
Generate the Arduino validation data (validation_data.h and validation_data.cpp)
files for unit tests from the 'validation_data' (or its JSON representation).
"""

import logging
import os
from typing import List
from typing import Set
from tzdb.transformer import div_to_zero
from tzdb.transformer import normalize_name
from .data import (TestItem, TestData, ValidationData)


class ArduinoValidationGenerator:
    """Generate Arduino data files for BasicPythonTest and ExtendedPythonTest.
    """

    def __init__(
        self,
        invocation: str,
        tz_version: str,
        scope: str,
        db_namespace: str,
        validation_data: ValidationData,
    ):
        self.invocation = invocation
        self.tz_version = tz_version
        self.db_namespace = db_namespace
        self.validation_data = validation_data

        self.test_data = validation_data['test_data']
        self.file_base = 'validation'
        self.include_header_namespace = 'VALIDATION'
        if scope == 'basic':
            self.test_class = 'BasicTransitionTest'
        else:
            self.test_class = 'ExtendedTransitionTest'
        self.validation_data_h_file_name = (self.file_base + '_data.h')
        self.validation_data_cpp_file_name = (self.file_base + '_data.cpp')
        self.validation_tests_file_name = (self.file_base + '_tests.cpp')

    def generate_files(self, output_dir: str) -> None:
        self._write_file(output_dir, self.validation_data_h_file_name,
                         self._generate_validation_data_h())
        self._write_file(output_dir, self.validation_data_cpp_file_name,
                         self._generate_validation_data_cpp())
        self._write_file(output_dir, self.validation_tests_file_name,
                         self._generate_tests_cpp())

    def _write_file(self, output_dir: str, filename: str, content: str) -> None:
        full_filename = os.path.join(output_dir, filename)
        with open(full_filename, 'w', encoding='utf-8') as output_file:
            print(content, end='', file=output_file)
        logging.info("Created %s", full_filename)

    def _generate_validation_data_h(self) -> str:
        validation_items = self._generate_validation_data_h_items(
            self.test_data)
        source = self.validation_data['source']
        version = self.validation_data['version']

        return f"""\
// This file was generated by the following script:
//
//   $ {self.invocation}
//
// TZ Database comes from:
//   * https://github.com/eggert/tz/releases/tag/{self.tz_version}
//
// Third party database comes from:
//    * {source} (version {version})
//
// DO NOT EDIT

#ifndef ACE_TIME_VALIDATION_TEST_{self.include_header_namespace}_DATA_H
#define ACE_TIME_VALIDATION_TEST_{self.include_header_namespace}_DATA_H

#include <ace_time/testing/ValidationDataType.h>

namespace ace_time {{
namespace {self.db_namespace} {{

// numZones: {len(self.test_data)}
{validation_items}

}}
}}

#endif
"""

    def _generate_validation_data_h_items(self, test_data: TestData) -> str:
        validation_items = ''
        for zone_name, test_items in sorted(test_data.items()):
            normalized_name = normalize_name(zone_name)
            validation_items += f"""\
extern const testing::ValidationData kValidationData{normalized_name};
"""

        return validation_items

    def _generate_validation_data_cpp(self) -> str:
        validation_items = self._generate_validation_data_cpp_items(
            self.test_data)
        source = self.validation_data['source']
        version = self.validation_data['version']

        return f"""\
// This file was generated by the following script:
//
//   $ {self.invocation}
//
// TZ Database comes from:
//   * https://github.com/eggert/tz/releases/tag/{self.tz_version}
//
// Third party database comes from:
//    * {source} (version {version})
//
// DO NOT EDIT

#include <ace_time/testing/ValidationDataType.h>
#include "{self.file_base}_data.h"

namespace ace_time {{
namespace {self.db_namespace} {{

{validation_items}

}}
}}
"""

    def _generate_validation_data_cpp_items(self, test_data: TestData) -> str:
        validation_items = ''
        for zone_name, test_items in sorted(test_data.items()):
            test_items_string = self._generate_validation_data_cpp_test_items(
                zone_name, test_items)
            normalized_name = normalize_name(zone_name)

            validation_item = f"""\
//---------------------------------------------------------------------------
// Zone name: {zone_name}
//---------------------------------------------------------------------------

static const testing::ValidationItem kValidationItems{normalized_name}[] = {{
  //     epoch,  utc,  dst,    y,  m,  d,  h,  m,  s,  abbrev, type
{test_items_string}
}};

const testing::ValidationData kValidationData{normalized_name} = {{
  {len(test_items)} /*numItems*/,
  kValidationItems{normalized_name} /*items*/,
}};

"""
            validation_items += validation_item
        return validation_items

    def _generate_validation_data_cpp_test_items(
        self,
        zone_name: str,
        test_items: List[TestItem],
    ) -> str:
        """Generate the C++ code snippet related to the List[TestItem].
        """
        s = ''
        for test_item in test_items:
            epoch_seconds = test_item['epoch']
            total_offset_minutes = div_to_zero(test_item['total_offset'], 60)
            delta_offset_minutes = div_to_zero(test_item['dst_offset'], 60)
            year = test_item['y']
            month = test_item['M']
            day = test_item['d']
            hour = test_item['h']
            minute = test_item['m']
            second = test_item['s']
            abbrev_value = test_item['abbrev']
            abbrev = f'"{abbrev_value}"' if abbrev_value else 'nullptr'
            type = test_item['type']

            test_item_code = f"""\
  {{ {epoch_seconds:10}, {total_offset_minutes:4}, {delta_offset_minutes:4}, \
{year:4}, {month:2}, {day:2}, {hour:2}, {minute:2}, {second:2}, {abbrev:>7}, \
'{type}' }},
"""
            s += test_item_code
        return s

    def _generate_tests_cpp(self) -> str:
        test_cases = self._generate_test_cases(self.test_data)
        source = self.validation_data['source']
        version = self.validation_data['version']

        return f"""\
// This file was generated by the following script:
//
//   $ {self.invocation}
//
// TZ Database comes from:
//   * https://github.com/eggert/tz/releases/tag/{self.tz_version}
//
// Third party database comes from:
//    * {source} (version {version})
//
// DO NOT EDIT

#include <AUnitVerbose.h>
#include <ace_time/testing/{self.test_class}.h>
#include "{self.file_base}_data.h"
#include "{self.db_namespace}/zone_infos.h"
#include "{self.db_namespace}/zone_policies.h"

using namespace ace_time::testing;
using namespace ace_time::{self.db_namespace};

// numZones: {len(self.test_data)}
{test_cases}
"""

    def _generate_test_cases(self, test_data: TestData) -> str:
        dst_blacklist: Set[str] = (
            set(self.validation_data.get('dst_blacklist') or [])
        )
        has_valid_abbrev = self.validation_data['has_valid_abbrev']
        has_valid_dst = self.validation_data['has_valid_dst']
        test_cases = ''
        for zone_name, _ in sorted(test_data.items()):
            normalized_name = normalize_name(zone_name)
            if has_valid_dst and (zone_name not in dst_blacklist):
                dst_validation_type = 'DstValidationType::kAll'
                test_dst_comment = ''
            else:
                dst_validation_type = 'DstValidationType::kNone'
                test_dst_comment = ' BLACKLISTED'
            test_abbrev = 'true' if has_valid_abbrev else 'false'

            test_case = f"""\
testF({self.test_class}, {normalized_name}) {{
  assertValid(
     &kZone{normalized_name},
     &kValidationData{normalized_name},
     {dst_validation_type} /*dstValidationType{test_dst_comment}*/,
     {test_abbrev} /*validateAbbrev*/);
}}
"""
            test_cases += test_case
        return test_cases
