# Copyright 2018 Brian T. Park
#
# MIT License
"""
Validate the inlined zonedb maps (zone_infos and zone_policies) generated by
ZoneInfoInliner by feeding them into ZoneProcessor, then comparing the results
of TestDataGenerator (which uses pytz).

TODO: Should this be rewritten as a python test? If this is not run in a
continuous integration pipeline, it's too easy to bitrot.
"""

from typing import List
import logging
from datetime import datetime

from acetime.common import SECONDS_SINCE_UNIX_EPOCH
from acetime.zonedb_types import ZoneInfoMap
from acetime.zonedb_types import ZonePolicyMap
from acetime.zone_processor import ZoneProcessor
from acetime.zone_processor import to_utc_string
from .zstdgenerator import TestDataGenerator
from .zstdgenerator import TestData
from .zstdgenerator import TestItem


class Validator:
    """Validate the zone_infos and zone_policies data from the TZ Database,
    as extracted and transformed by Extractor and Transformer. Provides
    2 validation methods:

        * validate_test_data(): to compare the DST transitions between
          those determined by pztz (through TestDataGenerator) and those
          determined by ZoneProcessor

    Usage:
        # For validation against pytz golden test data
        validator = Validator(zone_infos, zone_policies, ...)
        validator.validate_test_data()
    """

    def __init__(
        self,
        zone_infos: ZoneInfoMap,
        zone_policies: ZonePolicyMap,
        validate_dst_offset: bool,
        debug_validator: bool,
        debug_processor: bool,
        zone_name: str,
        year: int,
        start_year: int,
        until_year: int,
    ):
        """
        Args:
            zone_infos: {name -> zone_info{} }
            zone_policies: {name ->zone_policy{} }
            viewing_months: number of months in the calculation window
                (13, 14, 36)
            validate_dst_offset: validate DST offset against Python in
                addition to total UTC offset
            debug_validator: enable debugging output for Validator
            debug_processor: enable debugging output for ZoneProcessor
            zone_name: validate only this zone
            year: validate only this year
            start_year: start year of validation
            until_year: until year of validation
        """
        self.zone_infos = zone_infos
        self.zone_policies = zone_policies
        self.validate_dst_offset = validate_dst_offset
        self.debug_validator = debug_validator
        self.debug_processor = debug_processor
        self.zone_name = zone_name
        self.year = year
        self.start_year = start_year
        self.until_year = until_year

    # The following are public methods.

    def validate_test_data(self) -> None:
        """Compare Python and AceTime offsets by generating TestDataGenerator.
        """
        logging.info('Creating test data')
        data_generator = TestDataGenerator(
            self.zone_infos,
            self.zone_policies,
            self.start_year,
            self.until_year)
        (test_data, num_items) = data_generator.create_test_data()
        logging.info('Num zones: %d', len(test_data))
        logging.info('Num test items: %s', num_items)

        num_errors = self._validate_test_data(test_data)
        if num_errors:
            logging.info(f'Errors found with {num_errors} test items')
        else:
            logging.info('No errors found!')

    def _validate_test_data(self, test_data: TestData) -> int:
        num_errors = 0
        for zone_name, items in test_data.items():
            if self.zone_name and zone_name != self.zone_name:
                continue
            if self.debug_validator:
                logging.info('  Validating zone %s', zone_name)
            num_errors += self._validate_test_data_for_zone(zone_name, items)
        return num_errors

    def _validate_test_data_for_zone(
        self,
        zone_name: str,
        items: List[TestItem],
    ) -> int:
        """Compare the given test 'items' generatd by TestDataGenerator (using
        pytz) with the expected datetime components from ZoneProcessor. Returns
        the number of errors.
        """
        zone_info = self.zone_infos[zone_name]
        zone_processor = ZoneProcessor(
            zone_info=zone_info,
            debug=self.debug_processor,
        )

        num_errors = 0
        for item in items:
            if self.year is not None and self.year != item.y:
                continue

            # Print out diagnostics if mismatch detected or if debug flag given
            unix_seconds = item.epoch + SECONDS_SINCE_UNIX_EPOCH
            ldt = datetime.utcfromtimestamp(unix_seconds)
            header = (
                f'======== Testing {zone_name}; '
                f'at {_test_item_to_string(item)}w; '
                f'utc {ldt}; '
                f'epoch {item.epoch}; '
                f'unix {unix_seconds}'
            )

            if self.debug_processor:
                logging.info(header)

            info = zone_processor.get_timezone_info_for_seconds(item.epoch)
            if not info:
                logging.info("timezone info not found")
                continue

            is_matched = info.total_offset == item.total_offset
            status = '**Matched**' if is_matched else '**Mismatched**'
            ace_time_string = to_utc_string(info.utc_offset, info.dst_offset)
            utc_string = to_utc_string(
                item.total_offset - item.dst_offset,
                item.dst_offset
            )
            body = (
                f'{status}: '
                f'AceTime({ace_time_string}); '
                f'Expected({utc_string})'
            )
            if is_matched:
                if self.debug_processor:
                    logging.info(body)
                    zone_processor.print_matches_and_transitions()
            else:
                num_errors += 1
                if not self.debug_processor:
                    logging.error(header)
                logging.error(body)
                zone_processor.print_matches_and_transitions()

        return num_errors


def _test_item_to_string(i: TestItem) -> str:
    return f'{i.y:04}-{i.M:02}-{i.d:02}T{i.h:02}:{i.m:02}:{i.s:02}'
